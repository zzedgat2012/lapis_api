# Development Guide

Complete guide for developing with this Lapis API template.

> **Related Documentation:**
>
> - [2. Api](2.%20Api.md) - API endpoints reference
> - [3. Database](3.%20Database.md) - Database configuration
> - [4. Testing](4.%20Testing.md) - Testing guide

## Prerequisites

- Docker & Docker Compose
- Git
- curl or API client (Postman, Insomnia, etc.)
- Text editor (VS Code recommended)

## Initial Setup

```bash
# Clone repository
git clone <your-repo>
cd legal_api

# Start development environment
docker compose up

# In another terminal, verify it's running
curl http://localhost:8080
```

## Project Structure

```text
legal_api/
├── app.lua              # Main application entry point
├── config.lua           # Environment configurations  
├── models.lua           # Model auto-loader
├── nginx.conf           # OpenResty/nginx configuration
├── Dockerfile           # Container image definition
├── docker-compose.yml   # Development orchestration
├── .dockerjunk/         # Logs and temp files (gitignored)
├── docs/                # Documentation
├── tests/               # Test specifications
└── models/              # Database models (create as needed)
```

## Development Workflow

### 1. Make Code Changes

Edit any `.lua` file:

```bash
# Example: Edit app.lua
vim app.lua  # or use VS Code
```

### 2. Apply Changes

**Since `lua_code_cache on` (for data persistence):**

```bash
docker compose restart
```

This takes ~2 seconds.

### 3. Test Changes

```bash
# Manual test
curl http://localhost:8080/users

# Run automated tests
docker compose exec web busted
```

### 4. Scaffold New Resources (Optional)

Use the Makefile generator to create boilerplate for new models. The command runs inside the
Docker container so the files are generated with the correct environment.

```bash
# Create model + timestamped migration
make model NAME=Invoice

# Create model + migration + presenter/view/test stubs
make model NAME=Invoice SCAFFOLD=crud

# Pass raw flags if you prefer
make model ARGS="--name Invoice --scaffold crud"
```

The generator will:

- Add `models/invoice.lua` with a starter module
- Create `migrations/<timestamp>_create_invoice.lua` and register it in `migrations/init.lua`
- (Optional) Generate CRUD stubs under `presenters/`, `views/`, and `tests/`
- (Optional) Auto-register REST routes and `require` statements in `app.lua`
- (Optional) Append resource definitions to `openapi/spec.lua` so the docs and Swagger stay current

### 5. View Logs

```bash
# Follow logs
docker compose logs -f

# Or view log files
tail -f .dockerjunk/logs/error.log
tail -f .dockerjunk/logs/access.log
```

### 6. Roll Back Migrations

```bash
make rollback           # Roll back the last applied migration
make rollback STEPS=2   # Roll back the last two migrations in order
```

The rollback helper only works for migrations generated by the scaffold (they expose a `down()` routine). Older migrations without `down()` must still be handled manually.

## Database

> **See [3. Database](3.%20Database.md) for complete database configuration guide.**

### Switching Database Engines

The application now reads `DB_CONNECTION` to decide which driver to use (`sqlite`, `postgres`, or `mysql`).

#### MySQL (default)

- No extra steps—`DB_CONNECTION` defaults to `mysql`.
- The `mysql` service starts automatically with `docker compose up` and uses the credentials defined in `docker-compose.yml`.
- Run `make migrate` after the first boot to create the schema.

#### PostgreSQL (optional)

1. Export the engine selector and connection variables (or place them in a `.env`):

  ```bash
  export DB_CONNECTION=postgres
  export PGHOST=postgres
  export PGUSER=postgres
  export PGPASSWORD=postgres
  export PGDATABASE=legal_api
  ```

1. Bring the stack up with the postgres profile (the profile automatically starts the database service):

  ```bash
  docker compose --profile postgres up -d web postgres
  ```

1. Apply migrations:

  ```bash
  docker compose --profile postgres exec web lapis migrate
  ```

The container image already bundles the `pgmoon` driver, so no extra installation is necessary.

#### SQLite (optional)

1. Export the engine selector:

  ```bash
  export DB_CONNECTION=sqlite
  ```

1. (Optional) stop the MySQL service if you only want SQLite:

  ```bash
  docker compose stop mysql
  ```

1. Restart the web container so it reconnects using SQLite:

  ```bash
  docker compose up -d web
  ```

Data is stored in `.dockerjunk/development.db` and persists across restarts.

## Testing

### Run All Tests

```bash
docker compose exec web busted
```

### Run Specific Test File

```bash
docker compose exec web busted tests/user_spec.lua
```

### Write Tests

Create `tests/my_feature_spec.lua`:

```lua
describe("My Feature", function()
  it("should work correctly", function()
    local result = my_function()
    assert.are.equal("expected", result)
  end)
end)
```

See `docs/TESTING.md` for complete testing guide.

## Adding New Features

### Example: Add Posts Resource

#### 1. Create Model (if using DB)

```lua
-- models/post.lua
local Model = require("lapis.db.model").Model

local Posts = Model:extend("posts", {
  timestamp = true
})

return Posts
```

#### 2. Add Routes

```lua
-- In app.lua
local Posts = require("models.post")

app:get("/posts", function(self)
  local posts = Posts:select()
  return { json = { success = true, posts = posts } }
end)

app:post("/posts", function(self)
  local post = Posts:create({
    title = self.params.title,
    content = self.params.content
  })
  return { status = 201, json = { success = true, post = post } }
end)
```

#### 3. Add Tests

> **See [4. Testing](4.%20Testing.md) for complete testing guide.**

```lua
-- tests/post_spec.lua
describe("Posts API", function()
  it("should list posts", function()
    -- test implementation
  end)
end)
```

#### 4. Test & Deploy

```bash
docker compose restart
docker compose exec web busted tests/post_spec.lua
curl http://localhost:8080/posts
```

## Common Tasks

### Add Lua Package

Edit `Dockerfile`:

```dockerfile
RUN /usr/local/openresty/luajit/bin/luarocks install package-name
```

Then rebuild:

```bash
docker compose build
docker compose up
```

### Change Port

Edit `docker-compose.yml`:

```yaml
ports:
  - "3000:80"  # Change 8080 to 3000
```

### Enable Hot Reload

**Note:** This will lose in-memory data on each request.

Edit `nginx.conf`:

```nginx
lua_code_cache off;
```

```bash
docker compose restart
```

Now changes apply without restart (but data doesn't persist).

### View Database (PostgreSQL)

```bash
docker compose exec db psql -U postgres -d legal_api

# In psql:
\dt              # List tables
SELECT * FROM users;
\q               # Quit
```

## Debugging

### Check Container Status

```bash
docker compose ps
```

### View Logs

```bash
# All logs
docker compose logs

# Follow logs
docker compose logs -f

# Specific service
docker compose logs web
```

### Enter Container

```bash
docker compose exec web sh

# Inside container:
ls /app
cat /app/nginx.conf
exit
```

### Test nginx Configuration

```bash
docker compose exec web openresty -t
```

## Performance Tips

### Production Checklist

- [ ] `lua_code_cache on` in nginx.conf
- [ ] `worker_processes` set to number of CPUs
- [ ] Use PostgreSQL, not in-memory storage
- [ ] Remove development volumes from docker-compose
- [ ] Set `LAPIS_ENV=production`
- [ ] Enable gzip compression
- [ ] Set up proper logging
- [ ] Use connection pooling for DB

### nginx.conf for Production

```nginx
worker_processes 4;  # Match CPU cores

http {
  lua_code_cache on;
  gzip on;
  gzip_types application/json;
  
  # Connection pooling
  lua_socket_pool_size 30;
  
  server {
    listen 80;
    
    # ... rest of config
  }
}
```

## Troubleshooting

### Container Won't Start

```bash
# Check logs
docker compose logs

# Rebuild from scratch
docker compose down
docker compose build --no-cache
docker compose up
```

### Changes Not Applying

```bash
# Make sure to restart
docker compose restart

# Or stop and start
docker compose down
docker compose up
```

### "Module not found" Error

```bash
# Rebuild to install dependencies
docker compose build
docker compose up
```

### Port Already in Use

```bash
# Find what's using port 8080
lsof -i :8080

# Kill it or change port in docker-compose.yml
```

## Best Practices

1. **Always use `local`** for variables
2. **Validate input** before processing
3. **Return proper HTTP status codes**
4. **Write tests** for new features
5. **Use meaningful error messages**
6. **Keep routes in `app.lua`**, business logic in separate modules
7. **Don't commit `.dockerjunk/`** (already gitignored)
8. **Document API changes** in `docs/API.md`

## Resources

- [Lapis Documentation](https://leafo.net/lapis/)
- [OpenResty API](https://github.com/openresty/lua-nginx-module)
- [Lua 5.1 Reference](https://www.lua.org/manual/5.1/)
- [Busted Testing](https://olivinelabs.com/busted/)
