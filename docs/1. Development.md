# Development Guide

Complete guide for developing with this Lapis API template.

> **Related Documentation:**
>
> - [2. Api](2.%20Api.md) - API endpoints reference
> - [3. Database](3.%20Database.md) - Database configuration
> - [4. Testing](4.%20Testing.md) - Testing guide

## Prerequisites

- Docker & Docker Compose
- Git
- curl or API client (Postman, Insomnia, etc.)
- Text editor (VS Code recommended)

## Initial Setup

```bash
# Clone repository
git clone <your-repo>
cd legal_api

# Start development environment
docker compose up

# In another terminal, verify it's running
curl http://localhost:8080
```

## Project Structure

```text
legal_api/
├── app.lua              # Main application entry point
├── config.lua           # Environment configurations  
├── models.lua           # Model auto-loader
├── nginx.conf           # OpenResty/nginx configuration
├── Dockerfile           # Container image definition
├── docker-compose.yml   # Development orchestration
├── .dockerjunk/         # Logs and temp files (gitignored)
├── docs/                # Documentation
├── tests/               # Test specifications
└── models/              # Database models (create as needed)
```

## Development Workflow

### 1. Make Code Changes

Edit any `.lua` file:

```bash
# Example: Edit app.lua
vim app.lua  # or use VS Code
```

### 2. Apply Changes

**Since `lua_code_cache on` (for data persistence):**

```bash
docker compose restart
```

This takes ~2 seconds.

### 3. Test Changes

```bash
# Manual test
curl http://localhost:8080/users

# Run automated tests
docker compose exec web busted
```

### 4. Scaffold New Resources (Optional)

Use the Makefile generator to create boilerplate for new models. The command runs inside the
Docker container so the files are generated with the correct environment.

```bash
# Create model + timestamped migration
make model NAME=Invoice

# Create model + migration + presenter/view/test stubs
make model NAME=Invoice SCAFFOLD=crud

# Pass raw flags if you prefer
make model ARGS="--name Invoice --scaffold crud"
```

The generator will:

- Add `models/invoice.lua` with a starter module
- Create `migrations/<timestamp>_create_invoice.lua` and register it in `migrations/init.lua`
- (Optional) Generate CRUD stubs under `presenters/`, `views/`, and `tests/`
- (Optional) Auto-register REST routes and `require` statements in `app.lua`
- (Optional) Append resource definitions to `openapi/spec.lua` so the docs and Swagger stay current

### 5. View Logs

```bash
# Follow logs
docker compose logs -f

# Or view log files
tail -f .dockerjunk/logs/error.log
tail -f .dockerjunk/logs/access.log
```

### 6. Roll Back Migrations

```bash
make rollback           # Roll back the last applied migration
make rollback STEPS=2   # Roll back the last two migrations in order
```

The rollback helper only works for migrations generated by the scaffold (they expose a `down()` routine). Older migrations without `down()` must still be handled manually.

## Database

> **See [3. Database](3.%20Database.md) for complete database configuration guide.**

### Development (Current Setup)

Uses **SQLite** for data persistence:

```lua
-- In config.lua
sqlite = {
  database = "/app/.dockerjunk/development.db"
}
```

**Pros:**

- ✅ No setup required
- ✅ Fast for prototyping
- ✅ Data persists across restarts
- ✅ Works with hot-reload

**Cons:**

- ❌ Limited concurrency
- ❌ Not suitable for production (use PostgreSQL)

### Production Setup: PostgreSQL

#### 1. Add to docker-compose.yml

```yaml
services:
  web:
    # ... existing config ...
    depends_on:
      - db
    environment:
      - LAPIS_ENV=production
      - PGHOST=db
      - PGUSER=postgres
      - PGPASSWORD=postgres
      - PGDATABASE=legal_api

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: legal_api
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  postgres_data:
```

#### 2. Install PostgreSQL Driver

Update `Dockerfile`:

```dockerfile
RUN /usr/local/openresty/luajit/bin/luarocks install pgmoon
```

#### 3. Create Models

```lua
-- models/user.lua
local Model = require("lapis.db.model").Model

local Users = Model:extend("users", {
  timestamp = true  -- Adds created_at, updated_at
})

return Users
```

#### 4. Update config.lua

```lua
config("production", {
  postgres = {
    host = os.getenv("PGHOST"),
    user = os.getenv("PGUSER"),
    password = os.getenv("PGPASSWORD"),
    database = os.getenv("PGDATABASE")
  }
})
```

#### 5. Create Migrations

```lua
-- migrations/001_create_users.lua
local schema = require("lapis.db.schema")

return {
  [1] = function()
    schema.create_table("users", {
      { "id", schema.types.serial },
      { "name", schema.types.varchar },
      { "email", schema.types.varchar },
      { "created_at", schema.types.time },
      { "updated_at", schema.types.time },
      "PRIMARY KEY (id)"
    })
    
    schema.add_index("users", "email", { unique = true })
  end
}
```

Run migrations:

```bash
docker compose exec web lapis migrate
```

## Testing

### Run All Tests

```bash
docker compose exec web busted
```

### Run Specific Test File

```bash
docker compose exec web busted tests/user_spec.lua
```

### Write Tests

Create `tests/my_feature_spec.lua`:

```lua
describe("My Feature", function()
  it("should work correctly", function()
    local result = my_function()
    assert.are.equal("expected", result)
  end)
end)
```

See `docs/TESTING.md` for complete testing guide.

## Adding New Features

### Example: Add Posts Resource

#### 1. Create Model (if using DB)

```lua
-- models/post.lua
local Model = require("lapis.db.model").Model

local Posts = Model:extend("posts", {
  timestamp = true
})

return Posts
```

#### 2. Add Routes

```lua
-- In app.lua
local Posts = require("models.post")

app:get("/posts", function(self)
  local posts = Posts:select()
  return { json = { success = true, posts = posts } }
end)

app:post("/posts", function(self)
  local post = Posts:create({
    title = self.params.title,
    content = self.params.content
  })
  return { status = 201, json = { success = true, post = post } }
end)
```

#### 3. Add Tests

> **See [4. Testing](4.%20Testing.md) for complete testing guide.**

```lua
-- tests/post_spec.lua
describe("Posts API", function()
  it("should list posts", function()
    -- test implementation
  end)
end)
```

#### 4. Test & Deploy

```bash
docker compose restart
docker compose exec web busted tests/post_spec.lua
curl http://localhost:8080/posts
```

## Common Tasks

### Add Lua Package

Edit `Dockerfile`:

```dockerfile
RUN /usr/local/openresty/luajit/bin/luarocks install package-name
```

Then rebuild:

```bash
docker compose build
docker compose up
```

### Change Port

Edit `docker-compose.yml`:

```yaml
ports:
  - "3000:80"  # Change 8080 to 3000
```

### Enable Hot Reload

**Note:** This will lose in-memory data on each request.

Edit `nginx.conf`:

```nginx
lua_code_cache off;
```

```bash
docker compose restart
```

Now changes apply without restart (but data doesn't persist).

### View Database (PostgreSQL)

```bash
docker compose exec db psql -U postgres -d legal_api

# In psql:
\dt              # List tables
SELECT * FROM users;
\q               # Quit
```

## Debugging

### Check Container Status

```bash
docker compose ps
```

### View Logs

```bash
# All logs
docker compose logs

# Follow logs
docker compose logs -f

# Specific service
docker compose logs web
```

### Enter Container

```bash
docker compose exec web sh

# Inside container:
ls /app
cat /app/nginx.conf
exit
```

### Test nginx Configuration

```bash
docker compose exec web openresty -t
```

## Performance Tips

### Production Checklist

- [ ] `lua_code_cache on` in nginx.conf
- [ ] `worker_processes` set to number of CPUs
- [ ] Use PostgreSQL, not in-memory storage
- [ ] Remove development volumes from docker-compose
- [ ] Set `LAPIS_ENV=production`
- [ ] Enable gzip compression
- [ ] Set up proper logging
- [ ] Use connection pooling for DB

### nginx.conf for Production

```nginx
worker_processes 4;  # Match CPU cores

http {
  lua_code_cache on;
  gzip on;
  gzip_types application/json;
  
  # Connection pooling
  lua_socket_pool_size 30;
  
  server {
    listen 80;
    
    # ... rest of config
  }
}
```

## Troubleshooting

### Container Won't Start

```bash
# Check logs
docker compose logs

# Rebuild from scratch
docker compose down
docker compose build --no-cache
docker compose up
```

### Changes Not Applying

```bash
# Make sure to restart
docker compose restart

# Or stop and start
docker compose down
docker compose up
```

### "Module not found" Error

```bash
# Rebuild to install dependencies
docker compose build
docker compose up
```

### Port Already in Use

```bash
# Find what's using port 8080
lsof -i :8080

# Kill it or change port in docker-compose.yml
```

## Best Practices

1. **Always use `local`** for variables
2. **Validate input** before processing
3. **Return proper HTTP status codes**
4. **Write tests** for new features
5. **Use meaningful error messages**
6. **Keep routes in `app.lua`**, business logic in separate modules
7. **Don't commit `.dockerjunk/`** (already gitignored)
8. **Document API changes** in `docs/API.md`

## Resources

- [Lapis Documentation](https://leafo.net/lapis/)
- [OpenResty API](https://github.com/openresty/lua-nginx-module)
- [Lua 5.1 Reference](https://www.lua.org/manual/5.1/)
- [Busted Testing](https://olivinelabs.com/busted/)
