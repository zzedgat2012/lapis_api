# Testing Guide

Complete guide for testing with Busted framework.

> **Related Documentation:**
> - [1. Development](1.%20Development.md) - Setup and development workflow
> - [2. Api](2.%20Api.md) - API endpoints to test
> - [3. Database](3.%20Database.md) - Test database configuration

## Overview

This project uses [Busted](https://olivinelabs.com/busted/) - a feature-rich testing framework for Lua that provides:

- BDD-style test syntax (describe/it)
- Assertions and matchers
- Mocking and stubbing
- Test coverage
- Async testing support

## Installation

Busted is installed via LuaRocks in the Docker container:

```dockerfile
# Already in Dockerfile
RUN /usr/local/openresty/luajit/bin/luarocks install busted
```

## Running Tests

### Run All Tests

```bash
docker compose exec web busted
```

Output:

```
●●●●●
5 successes / 0 failures / 0 errors / 0 pending : 0.123 seconds
```

### Run Specific Test File

```bash
docker compose exec web busted tests/user_spec.lua
```

### Run with Verbose Output

```bash
docker compose exec web busted --verbose
```

### Watch Mode (Auto-run on Changes)

Unfortunately, Busted doesn't have built-in watch mode. Use this workaround:

```bash
# Install entr (one-time)
docker compose exec web apk add entr

# Watch and re-run tests
find tests -name "*.lua" | docker compose exec -T web entr busted
```

## Test Structure

### Basic Test File

Create `tests/example_spec.lua`:

```lua
describe("Example Feature", function()
  it("should work correctly", function()
    local result = 2 + 2
    assert.are.equal(4, result)
  end)
  
  it("should handle edge cases", function()
    local result = 0 + 0
    assert.are.equal(0, result)
  end)
end)
```

### Test Organization

```
tests/
├── user_spec.lua         # User CRUD tests
├── auth_spec.lua         # Authentication tests
├── validation_spec.lua   # Input validation tests
└── helpers/
    └── test_helpers.lua  # Shared utilities
```

## Writing Tests

### Basic Assertions

```lua
describe("Assertions", function()
  it("should test equality", function()
    assert.are.equal(5, 2 + 3)
  end)
  
  it("should test truthiness", function()
    assert.is_true(true)
    assert.is_false(false)
    assert.is_nil(nil)
  end)
  
  it("should test types", function()
    assert.is_string("hello")
    assert.is_number(42)
    assert.is_table({})
  end)
  
  it("should test patterns", function()
    assert.matches("hello", "hello world")
  end)
end)
```

### Testing Tables

```lua
describe("Tables", function()
  it("should test table equality", function()
    local t1 = { a = 1, b = 2 }
    local t2 = { a = 1, b = 2 }
    assert.are.same(t1, t2)
  end)
  
  it("should test table contents", function()
    local users = { "alice", "bob" }
    assert.are.equal(2, #users)
  end)
end)
```

### Setup and Teardown

```lua
describe("User Management", function()
  local users
  
  before_each(function()
    -- Run before each test
    users = {}
    print("Setup: Created empty users table")
  end)
  
  after_each(function()
    -- Run after each test
    users = nil
    print("Teardown: Cleared users table")
  end)
  
  it("should add user", function()
    table.insert(users, { id = 1, name = "Alice" })
    assert.are.equal(1, #users)
  end)
  
  it("should have clean state", function()
    -- users is reset before this test
    assert.are.equal(0, #users)
  end)
end)
```

### Pending Tests

```lua
describe("Future Features", function()
  pending("should implement pagination", function()
    -- Test will be marked as pending
  end)
  
  it("should implement sorting")
  -- No function = pending test
end)
```

## Testing HTTP APIs

### Option 1: Mock HTTP Requests

```lua
local lapis = require("lapis")
local app = require("app")

describe("Users API", function()
  it("should list users", function()
    local mock_request = {
      method = "GET",
      url = "/users"
    }
    
    -- This is simplified - real testing requires mock_request setup
    -- See Lapis testing documentation
  end)
end)
```

### Option 2: Use curl in Tests

```lua
describe("Users API Integration", function()
  it("should create user via HTTP", function()
    local handle = io.popen([[
      curl -s -X POST http://localhost:8080/users \
        -H "Content-Type: application/json" \
        -d '{"name": "Test User", "email": "test@example.com"}'
    ]])
    
    local response = handle:read("*a")
    handle:close()
    
    assert.matches('"success":true', response)
  end)
end)
```

### Option 3: Test Business Logic Directly

**Recommended approach:**

```lua
-- In app.lua, separate business logic:
local UserService = {}

function UserService.create_user(name, email)
  if not name or not email then
    return nil, "Name and email are required"
  end
  
  -- Check duplicate email
  for _, user in pairs(_G.users) do
    if user.email == email then
      return nil, "Email already exists"
    end
  end
  
  local user = {
    id = _G.next_id,
    name = name,
    email = email
  }
  
  _G.users[_G.next_id] = user
  _G.next_id = _G.next_id + 1
  
  return user
end

return UserService
```

```lua
-- tests/user_service_spec.lua
local UserService = require("user_service")

describe("UserService", function()
  before_each(function()
    _G.users = {}
    _G.next_id = 1
  end)
  
  describe("create_user", function()
    it("should create valid user", function()
      local user, err = UserService.create_user("Alice", "alice@example.com")
      
      assert.is_nil(err)
      assert.is_not_nil(user)
      assert.are.equal("Alice", user.name)
      assert.are.equal("alice@example.com", user.email)
      assert.are.equal(1, user.id)
    end)
    
    it("should reject missing name", function()
      local user, err = UserService.create_user(nil, "alice@example.com")
      
      assert.is_nil(user)
      assert.are.equal("Name and email are required", err)
    end)
    
    it("should reject duplicate email", function()
      UserService.create_user("Alice", "alice@example.com")
      local user, err = UserService.create_user("Bob", "alice@example.com")
      
      assert.is_nil(user)
      assert.are.equal("Email already exists", err)
    end)
  end)
end)
```

## Advanced Testing

### Mocking

```lua
local mock = require("luassert.mock")

describe("External API", function()
  it("should mock HTTP calls", function()
    local http = mock(require("socket.http"))
    http.request.returns("mocked response")
    
    local result = http.request("http://example.com")
    
    assert.are.equal("mocked response", result)
    assert.stub(http.request).was.called_with("http://example.com")
  end)
end)
```

### Spying

```lua
local spy = require("luassert.spy")

describe("Callbacks", function()
  it("should call callback", function()
    local callback = spy.new(function() end)
    
    local function execute(cb)
      cb()
    end
    
    execute(callback)
    
    assert.spy(callback).was.called()
    assert.spy(callback).was.called(1) -- Called exactly once
  end)
end)
```

### Stubbing

```lua
local stub = require("luassert.stub")

describe("Database", function()
  it("should stub database calls", function()
    local db = { query = function() end }
    stub(db, "query").returns({ { id = 1, name = "Alice" } })
    
    local result = db.query("SELECT * FROM users")
    
    assert.are.equal("Alice", result[1].name)
  end)
end)
```

## Test Coverage

### Generate Coverage Report

```bash
# Install luacov
docker compose exec web /usr/local/openresty/luajit/bin/luarocks install luacov

# Run tests with coverage
docker compose exec web busted --coverage

# Generate report
docker compose exec web luacov

# View report
docker compose exec web cat luacov.report.out
```

### Coverage Configuration

Create `.busted`:

```lua
return {
  _all = {
    coverage = true,
    verbose = true
  },
  
  default = {
    ROOT = {"tests/"}
  }
}
```

## CI/CD Integration

### GitHub Actions

Create `.github/workflows/test.yml`:

```yaml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Build Docker image
        run: docker compose build
      
      - name: Run tests
        run: docker compose run web busted
      
      - name: Generate coverage
        run: |
          docker compose run web busted --coverage
          docker compose run web luacov
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./luacov.report.out
```

## Best Practices

### 1. Test Naming

```lua
-- Good
describe("UserService.create_user", function()
  it("should create user with valid data", function() ... end)
  it("should reject missing email", function() ... end)
end)

-- Bad
describe("Tests", function()
  it("test1", function() ... end)
end)
```

### 2. One Assertion Per Test

```lua
-- Good
it("should set user name", function()
  assert.are.equal("Alice", user.name)
end)

it("should set user email", function()
  assert.are.equal("alice@example.com", user.email)
end)

-- Avoid (harder to debug)
it("should set all user fields", function()
  assert.are.equal("Alice", user.name)
  assert.are.equal("alice@example.com", user.email)
  assert.are.equal(1, user.id)
end)
```

### 3. Use before_each for Setup

```lua
describe("User Tests", function()
  local user
  
  before_each(function()
    user = { id = 1, name = "Alice" }
  end)
  
  it("should have correct id", function()
    assert.are.equal(1, user.id)
  end)
end)
```

### 4. Test Edge Cases

```lua
describe("divide", function()
  it("should divide positive numbers", function()
    assert.are.equal(2, divide(10, 5))
  end)
  
  it("should divide negative numbers", function()
    assert.are.equal(-2, divide(-10, 5))
  end)
  
  it("should handle division by zero", function()
    local result, err = divide(10, 0)
    assert.is_nil(result)
    assert.is_not_nil(err)
  end)
end)
```

### 5. Keep Tests Fast

```lua
-- Good: Direct function testing
it("should validate email", function()
  assert.is_true(validate_email("test@example.com"))
end)

-- Avoid: Full HTTP stack for unit tests
it("should validate email", function()
  local response = http.post("/validate", { email = "test@example.com" })
  -- This is slow and should be an integration test
end)
```

## Common Patterns

### Testing Validation

```lua
describe("Email Validation", function()
  local validate_email = require("validators").validate_email
  
  it("should accept valid emails", function()
    assert.is_true(validate_email("user@example.com"))
    assert.is_true(validate_email("user+tag@example.co.uk"))
  end)
  
  it("should reject invalid emails", function()
    assert.is_false(validate_email("invalid"))
    assert.is_false(validate_email("@example.com"))
    assert.is_false(validate_email("user@"))
  end)
end)
```

### Testing Error Handling

```lua
describe("Error Handling", function()
  it("should return error for invalid input", function()
    local result, err = process_user(nil)
    
    assert.is_nil(result)
    assert.are.equal("User data required", err)
  end)
end)
```

### Testing Async Operations

```lua
describe("Async Operations", function()
  it("should handle async callback", function(done)
    async_operation(function(result)
      assert.are.equal("success", result)
      done()
    end)
  end)
end)
```

## Debugging Tests

### Print Debugging

```lua
it("should debug values", function()
  local user = get_user(1)
  print("User:", require("inspect")(user))
  
  assert.is_not_nil(user)
end)
```

### Run Single Test

```bash
docker compose exec web busted --filter="should create user"
```

### Verbose Output

```bash
docker compose exec web busted --verbose --output=TAP
```

## Resources

- [Busted Documentation](https://olivinelabs.com/busted/)
- [luassert Documentation](https://github.com/Olivine-Labs/luassert)
- [Lapis Testing Guide](https://leafo.net/lapis/reference/testing.html)
- [Lua Testing Patterns](http://lua-users.org/wiki/UnitTesting)

## Next Steps

1. Write tests for all existing endpoints
2. Set up CI/CD pipeline
3. Add coverage requirements (e.g., 80% minimum)
4. Create integration test suite
5. Add performance/load tests
